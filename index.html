<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>囲碁アプリ v3（変化図ツリー付き）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      background-color: #f4f4f4;
    }
    canvas {
      background-color: #f4d9ae;
      border: 2px solid #000;
      margin-top: 10px;
      touch-action: none;
      max-width: 95vw;
      height: auto;
    }
    #recordList, #sgfTreeContainer {
      max-width: 500px;
      margin: 10px auto;
      text-align: left;
      font-size: 14px;
      padding: 0 1em;
    }
    button, input[type="text"], textarea, select {
      margin: 5px;
      padding: 8px 14px;
      font-size: 16px;
    }
    .dark canvas { background-color: #333; }
    .dark body { background-color: #111; color: white; }
  </style>
</head>
<body>
  <h1>囲碁アプリ v3（変化図ツリー付き）</h1>

  <canvas id="goban" width="600" height="600"></canvas>

  <div>
    <input type="file" accept=".sgf" onchange="loadSGF(event)">
  </div>

  <p id="moveCount">手数: 0</p>
  <ul id="recordList"></ul>

  <h3>📜 手順ツリー</h3>
  <div id="sgfTreeContainer"></div>

  <script>
    const canvas = document.getElementById("goban");
    const ctx = canvas.getContext("2d");
    const size = 19;
    const cell = canvas.width / (size + 1);
    let board = Array.from({ length: size }, () => Array(size).fill(0));
    let moveHistory = [];
    const abc = "abcdefghjklmnopqrst";
    const kanji = ["一","二","三","四","五","六","七","八","九","十","十一","十二","十三","十四","十五","十六","十七","十八","十九"];

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = `${cell * 0.4}px sans-serif`;
      ctx.fillStyle = "#000";
      for (let i = 0; i < size; i++) {
        ctx.fillText(abc[i].toUpperCase(), (i + 1) * cell - cell * 0.15, cell * 0.7);
        ctx.fillText(kanji[i], cell * 0.1, (i + 1) * cell + cell * 0.15);
      }
      ctx.strokeStyle = "#000";
      for (let i = 1; i <= size; i++) {
        ctx.beginPath();
        ctx.moveTo(cell, i * cell);
        ctx.lineTo(size * cell, i * cell);
        ctx.moveTo(i * cell, cell);
        ctx.lineTo(i * cell, size * cell);
        ctx.stroke();
      }
      for (let i = 0; i < moveHistory.length; i++) {
        const {x, y, color} = moveHistory[i];
        ctx.beginPath();
        ctx.arc((x + 1) * cell, (y + 1) * cell, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = color === 1 ? "black" : "white";
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = color === 1 ? "white" : "black";
        ctx.font = `${cell * 0.35}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(i + 1, (x + 1) * cell, (y + 1) * cell);
      }
      document.getElementById("moveCount").textContent = `手数: ${moveHistory.length}`;
    }

    function addRecord(color, x, y) {
      const coord = `${x + 1}の${kanji[y]}`;
      const li = document.createElement("li");
      li.textContent = `${moveHistory.length}. ${color === 1 ? "黒" : "白"}が ${coord} に打ちました`;
      document.getElementById("recordList").appendChild(li);
    }

    function resetBoard() {
      board = Array.from({ length: size }, () => Array(size).fill(0));
      moveHistory = [];
      document.getElementById("recordList").innerHTML = "";
      drawBoard();
    }

    function parseSGFToTree(sgf) {
      let index = 0;
      function parseNode() {
        const node = { move: null, children: [] };
        const moveMatch = sgf.slice(index).match(/;([BW])\[([a-s]{2})\]/i);
        if (moveMatch) {
          const [full, color, coords] = moveMatch;
          const x = abc.indexOf(coords[0]);
          const y = abc.indexOf(coords[1]);
          node.move = { color: color === "B" ? 1 : 2, x, y };
          index += sgf.slice(index).indexOf(full) + full.length;
        }
        return node;
      }

      function parseSequence() {
        const children = [];
        while (index < sgf.length) {
          const char = sgf[index];
          if (char === ";") {
            const node = parseNode();
            if (node.move) children.push(node);
          } else if (char === "(") {
            index++;
            const branch = parseSequence();
            if (children.length) {
              children[children.length - 1].children.push(branch);
            }
          } else if (char === ")") {
            index++;
            break;
          } else {
            index++;
          }
        }
        return children.length === 1 ? children[0] : { move: null, children };
      }

      return parseSequence();
    }

    function renderSGFTree(root, container) {
      container.innerHTML = "";
      function renderNode(node, depth = 0) {
        const div = document.createElement("div");
        div.style.marginLeft = `${depth * 16}px`;

        if (node.move) {
          const label = document.createElement("span");
          const turnLabel = node.move.color === 1 ? "●" : "○";
          label.textContent = `${turnLabel} (${node.move.x + 1}, ${node.move.y + 1})`;
          label.style.cursor = "pointer";
          label.onclick = () => replayToNode(node);
          div.appendChild(label);
        }

        if (node.children.length > 0) {
          const toggle = document.createElement("span");
          toggle.textContent = " ▶";
          toggle.style.cursor = "pointer";
          toggle.style.marginLeft = "6px";
          let expanded = false;

          const childContainer = document.createElement("div");
          childContainer.style.display = "none";

          toggle.onclick = () => {
            expanded = !expanded;
            childContainer.style.display = expanded ? "block" : "none";
            toggle.textContent = expanded ? " ▼" : " ▶";
          };

          div.appendChild(toggle);
          node.children.forEach(child => {
            childContainer.appendChild(renderNode(child, depth + 1));
          });
          div.appendChild(childContainer);
        }

        return div;
      }
      container.appendChild(renderNode(root));
    }

    function replayToNode(targetNode) {
      resetBoard();
      function walk(node) {
        if (node.move) {
          board[node.move.y][node.move.x] = node.move.color;
          moveHistory.push({...node.move});
          addRecord(node.move.color, node.move.x, node.move.y);
        }
        if (node.children.length > 0) {
          walk(node.children[0]);
        }
      }
      walk(targetNode);
      drawBoard();
    }

    function loadSGF(event) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const content = e.target.result;
        const tree = parseSGFToTree(content);
        renderSGFTree(tree, document.getElementById("sgfTreeContainer"));
        replayToNode(tree);
      };
      reader.readAsText(event.target.files[0]);
    }

    drawBoard();
  </script>
</body>
</html>